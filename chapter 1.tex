\documentclass[12pt]{article}

\title{Chapter 1}
\author{Uri Dvir \\ Computational Complexity - A Modern Approach (2016 ed.)}
\date{worked on 12/23/2023}

\usepackage{amssymb}
\usepackage{amsmath}

\newcommand{\qed}{\null \hfill $\square$}

\renewcommand{\labelenumi}{(\alph{enumi})}
\renewcommand{\labelenumii}{\arabic{enumii}.}

\newcommand{\Unit}[1]{\,\text{#1} \,}

\begin{document}

\maketitle

\section*{Exercise 1}

\begin{enumerate}
\item{
To compute the addition function, we will describe a Turing machine with 1 input tape, 3 work tapes, and one output tape. The input $\langle x, y \rangle$ is encoded with deliminator $\#$ by $0 \rightarrow 00$, $1 \rightarrow 11$, $\# \rightarrow 01$.
\begin{enumerate}
\item{Seek right on the input tape until we arrive at the first $\square$.}
\item{Copy $y$ backwards to work tape 1.}
\item{Copy $x$ backwards to work tape 2.}
\item{Seek left on work tapes 1 and 2 until we arrive at $\triangleright$ on both.}
\item{Until both work tapes 1 and 2 read $\square$ and there is no carry, go to the next step. Otherwise, skip the next step.}
\item{Add the bits from work tape 1 and work tape 2 together (treating $\square$ as 0), write the result to work tape 3, and set the carry appropriately. Seek right on all three tapes and repeat the previous step.}
\item{Copy work tape 3 backwards to output and halt.}
\end{enumerate}
}
\pagebreak
\item{
For the multiplication function, we will have 4 work tapes. These are $\tau_x$, $\tau_y$, $\tau_{count}$, and $\tau_{sum}$. The encoding is the same as before. We will use bit-shifting to do the multiplication.
\begin{enumerate}
\item{Seek right to $\square$ on the input tape.}
\item{Copy $y$ backwards to $\tau_y$.}
\item{Copy $x$ backwards to $\tau_x$.}
\item{Seek to $\triangleright$ on $\tau_x$ and $\tau_y$, then seek right on $\tau_x$.}
\item{Add the bits of $\tau_{count}$ (leading zeros) to $\tau_{sum}$ and then seek to $\triangleright$ for $\tau_{count}$ but not for $\tau_{sum}$.}
\item{If $\tau_x$ reads 1, add the bits of $\tau_y$ to $\tau_{sum}$, directly after the leading zeros added in the last step.}
\item{Seek right on $\tau_x$, and skip to step 10 if we read $\square$.}
\item{Seek right to $\square$, write 0, then seek to $\triangleright$ on $\tau_{count}$.}
\item{Seek to $\triangleright$ for $\tau_{sum}$ and repeat step 5.}
\item{Seek right to $\square$ on $\tau_{sum}$ then copy $\tau_{sum}$ backwards to output, and halt.}
\end{enumerate}
}
\end{enumerate}

\section*{Exercise 2}

%Complete the proof of Claim 1.5 by writing down explicitly the description of the
% machine ËœM.
To simulate $M$, the machine $\tilde{M}$ will (1) read $\log|\Gamma|$ symbols from the tapes (seeking right), (2) write $\log|\Gamma|$ symbols to the tapes (seeking left), and then (3) seek left or right by $\log|\Gamma|$ positions, or not at all, on each tape. This will take $3\log|\Gamma|$ steps, which is within $4\log|\Gamma|$ steps. After the seek phase, we go back to the read phase.
\begin{itemize}
\item{To read $\log|\Gamma|$ symbols, we descend down a binary tree $R$ of states. Each state $r_s$ corresponds to a prefix bit-string $s$. When we read a symbol $\tilde{\sigma} \in \{0,1\}$ in state $r_s$, we enter a new state $r_{s\tilde{\sigma}}$. Since we have $k$ tapes, we have $k$ trees represented by the product $R^k$.}
\item{To write $\log|\Gamma|$ symbols to $k$ tapes, we have a sequence of states for every symbol $\sigma \in \Gamma$ we just read, represented by $\Gamma^k \times \mathbb{N}_{\log|\Gamma|}$.}
\item{The seeking states have the same structure as those for writes, $\Gamma^k \times \mathbb{N}_{\log|\Gamma|}$.}
\end{itemize}
The behavior of each read, write, or seek state of $\tilde{M}$ is also determined by the active state $q$ of $M$. Therefore we can write
$$
\tilde{Q} = Q \times \left(
(\textsf{READ}, R^k) \cup
(\textsf{WRITE}, \Gamma^k \times \mathbb{N}_{\log|\Gamma|}) \cup
(\textsf{SEEK}, \Gamma^k \times \mathbb{N}_{\log|\Gamma|})
\right)
$$
We can now write a transition function for $\tilde{M}$. Given an encoding function $\textsf{enc} \,:\, \Gamma \rightarrow \{0,1\}^{\log|\Gamma|}$,
\begin{multline*}
\tilde{\delta}
((q, \textsf{READ}, (r_{s}, ...)), \tilde{\sigma}) = \\
\begin{cases}
(q, \textsf{READ}, (r_{s\tilde{\sigma}}, ...)), \tilde{\sigma}, \textsf{R}^k &
\text{if } |s\tilde{\sigma}| < \log|\Gamma| \\
(q, \textsf{WRITE}, \textsf{enc}^{-1}((s\tilde{\sigma}, ...), \log|\Gamma|), \tilde{\sigma}, \textsf{S}^k &
\text{if } |s\tilde{\sigma}| = \log|\Gamma|
\end{cases}
\end{multline*}
\begin{multline*}
\tilde{\delta}
((q, \textsf{WRITE}, (\sigma_i), j), \tilde{\sigma}) = \\
\begin{cases}
(q, \textsf{WRITE}, (\sigma_i), j-1), \{ \textsf{enc}(\sigma')_j \,;\, \sigma' \in \delta(q,(\sigma_i))_2 \}, \textsf{L}^k &
\text{if } j > 1 \\
(q, \textsf{SEEK}, (\sigma_i), \log|\Gamma|), \{ \textsf{enc}(\sigma')_1 \,;\, \sigma' \in \delta(q,(\sigma_i))_2 \}, \textsf{S}^k &
\text{if } j = 1
\end{cases}
\end{multline*}
\begin{multline*}
\tilde{\delta}
((q, \textsf{SEEK}, (\sigma_i), j), \tilde{\sigma}) =
\begin{cases}
(q, \textsf{SEEK}, (\sigma_i), j-1),  \tilde{\sigma}, \delta(q,(\sigma_i))_3 &
\text{if } j > 1 \\
(\delta(q,(\sigma_i))_1, \textsf{READ}, (r_{\epsilon},...)), \tilde{\sigma}, \textsf{S}^k &
\text{if } j = 1
\end{cases}
\end{multline*}
TODO: Refactor $r_s$ to $s$ in the read case, and correctly handle start and halt states.

\end{document}