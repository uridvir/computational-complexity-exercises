\documentclass[12pt]{article}

\title{Chapter 1}
\author{Uri Dvir \\ Computational Complexity - A Modern Approach (2016 ed.)}
\date{worked on 12/23/2023}

\usepackage{amssymb}
\usepackage{amsmath}

\newcommand{\qed}{\null \hfill $\square$}

\renewcommand{\labelenumi}{(\alph{enumi})}
\renewcommand{\labelenumii}{\arabic{enumii}.}

\newcommand{\Unit}[1]{\,\text{#1} \,}

\begin{document}

\maketitle

\section*{Exercise 1}

\begin{enumerate}
\item{
To compute the addition function, we will describe a Turing machine with 1 input tape, 3 work tapes, and one output tape. The input $\langle x, y \rangle$ is encoded with deliminator $\#$ by $0 \rightarrow 00$, $1 \rightarrow 11$, $\# \rightarrow 01$.
\begin{enumerate}
\item{Seek right on the input tape until we arrive at the first $\square$.}
\item{Copy $y$ backwards to work tape 1.}
\item{Copy $x$ backwards to work tape 2.}
\item{Seek left on work tapes 1 and 2 until we arrive at $\triangleright$ on both.}
\item{Until both work tapes 1 and 2 read $\square$ and there is no carry, go to the next step. Otherwise, skip the next step.}
\item{Add the bits from work tape 1 and work tape 2 together (treating $\square$ as 0), write the result to work tape 3, and set the carry appropriately. Seek right on all three tapes and repeat the previous step.}
\item{Copy work tape 3 backwards to output and halt.}
\end{enumerate}
}
\pagebreak
\item{
For the multiplication function, we will have 4 work tapes. These are $\tau_x$, $\tau_y$, $\tau_{count}$, and $\tau_{sum}$. The encoding is the same as before. We will use bit-shifting to do the multiplication.
\begin{enumerate}
\item{Seek right to $\square$ on the input tape.}
\item{Copy $y$ backwards to $\tau_y$.}
\item{Copy $x$ backwards to $\tau_x$.}
\item{Seek to $\triangleright$ on $\tau_x$ and $\tau_y$, then seek right on $\tau_x$.}
\item{Add the bits of $\tau_{count}$ (leading zeros) to $\tau_{sum}$ and then seek to $\triangleright$ for $\tau_{count}$ but not for $\tau_{sum}$.}
\item{If $\tau_x$ reads 1, add the bits of $\tau_y$ to $\tau_{sum}$, directly after the leading zeros added in the last step.}
\item{Seek right on $\tau_x$, and skip to step 10 if we read $\square$.}
\item{Seek right to $\square$, write 0, then seek to $\triangleright$ on $\tau_{count}$.}
\item{Seek to $\triangleright$ for $\tau_{sum}$ and repeat step 5.}
\item{Seek right to $\square$ on $\tau_{sum}$ then copy $\tau_{sum}$ backwards to output, and halt.}
\end{enumerate}
}
\end{enumerate}

\section*{Exercise 2}

%Complete the proof of Claim 1.5 by writing down explicitly the description of the
% machine ËœM.
Every state in the machine $M$ maps to some set of states in $\tilde{M}$.
To simulate reading a symbol from $\Gamma$, $\tilde{M}$ reads $\log|\Gamma|$ bits. Let's implement this with a binary tree! Let the set of states in the tree be $T_\Gamma$. The tree will have $\log|\Gamma|$ layers, and so we have
$$|T_\Gamma| = 2^{\lceil\log|\Gamma|\rceil} - 1$$
Each node represents a prefix, such as 001, that has been read already. Transitions down the tree will seek while reading more bits, while transitions from leaf nodes go to other trees. For example, reading the letter ``m" like in the textbook might look like this:
$$
q_{start, \epsilon} \rightarrow q_{start,0} \rightarrow q_{start,01} \rightarrow q_{start,011} \rightarrow q_{start,0110} \rightarrow q_{next,\epsilon}
$$
Reading the last 1 sends us to the next state, rather than to a 01101 state. This example also illustrates how we can have multiple trees for each state. We can express the new states as a product,
$$
Q' = Q \times T_\Gamma
$$
Starting from here (and also accounting for writes), we can now start formally describing the new transition function $\delta'$.

\end{document}